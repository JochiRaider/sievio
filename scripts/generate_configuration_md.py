#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
"""
Generate docs/CONFIGURATION.md from Sievio's dataclass-based config definitions.

Run:
    PYTHONPATH=src python3 scripts/generate_configuration_md.py
"""
from __future__ import annotations

from dataclasses import MISSING, fields, is_dataclass
from pathlib import Path
from typing import Any, get_args, get_origin, get_type_hints

ROOT = Path(__file__).resolve().parents[1]
import sys

sys.path.insert(0, str(ROOT / "src"))

from sievio.core import config as cfg  # noqa: E402

OUTPUT_PATH = ROOT / "docs" / "CONFIGURATION.md"


def type_repr(tp: Any) -> str:
    origin = get_origin(tp)
    if origin is None:
        if tp is None:
            return "None"
        return getattr(tp, "__name__", repr(tp))
    args = get_args(tp)
    name = getattr(origin, "__name__", str(origin))
    if args:
        return f"{name}[{', '.join(type_repr(a) for a in args)}]"
    return name


def default_repr(f) -> str:
    if f.default is not MISSING:
        return repr(f.default)
    if f.default_factory is not MISSING:  # pragma: no cover - simple formatting
        factory = f.default_factory  # type: ignore[attr-defined]
        return f"<factory {getattr(factory, '__name__', repr(factory))}>"
    return "required"


def iter_dataclass_types(tp: Any):
    origin = get_origin(tp)
    if origin is None:
        if isinstance(tp, type) and is_dataclass(tp):
            yield tp
        return
    for arg in get_args(tp):
        yield from iter_dataclass_types(arg)


def collect_dataclasses(root_cls):
    order: list[type] = []
    seen: set[type] = set()
    queue = [root_cls]
    while queue:
        cls = queue.pop(0)
        if cls in seen or not is_dataclass(cls):
            continue
        seen.add(cls)
        order.append(cls)
        hints = get_type_hints(cls, vars(cfg))
        for tp in hints.values():
            for dc in iter_dataclass_types(tp):
                if dc not in seen:
                    queue.append(dc)
    # Keep SievioConfig first, then sort remaining alphabetically for stability.
    head = [cls for cls in order if cls.__name__ == "SievioConfig"]
    tail = sorted([cls for cls in order if cls.__name__ != "SievioConfig"], key=lambda c: c.__name__)
    return head + tail


def render_dataclass(cls) -> str:
    lines = []
    lines.append(f"## {cls.__name__}")
    lines.append("")
    doc = (cls.__doc__ or "").strip()
    if doc:
        lines.append(doc)
        lines.append("")
    lines.append("| Field | Type | Default |")
    lines.append("| --- | --- | --- |")
    hints = get_type_hints(cls, vars(cfg))
    for f in fields(cls):
        tp = hints.get(f.name, f.type)
        lines.append(f"| `{f.name}` | `{type_repr(tp)}` | `{default_repr(f)}` |")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    classes = collect_dataclasses(cfg.SievioConfig)
    sections = [
        "# Sievio Configuration Reference",
        "",
        "> Generated by `scripts/generate_configuration_md.py` from `sievio.core.config`. Do not edit by hand.",
        "",
    ]
    for cls in classes:
        sections.append(render_dataclass(cls))
    OUTPUT_PATH.write_text("\n".join(sections) + "\n", encoding="utf-8")
    print(f"Wrote {OUTPUT_PATH}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
